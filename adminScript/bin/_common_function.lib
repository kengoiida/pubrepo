#!/bin/ksh
################################################################################
# 機能概要      : 共通関数定義
# 実行仕様      : 各スクリプトにて読み込んで使用する
# 読込ファイル  : None
# 書込ファイル  : None
# 戻り値        : None
# 更新履歴      : 
################################################################################
# ------------------------------------------------------------------------------
# メッセージ本文取得共通関数
#           引数: [$1:メッセージID]
#           戻値: [$message:メッセージ本文  $priority:メッセージレベル  $syslog_priority:SYSLOG指定用プライオリティー]
#           使用例: getMessage "000001I"
# ------------------------------------------------------------------------------
getMessage() {
(( ${DBG_FLG} )) && set -x

    messageid="$1"
    messageline=$(cat ${MSGLIST} | grep -w ^"${messageid:-999001W}")
    message=""

    case "${G_SCR_LANG}" in
        JP)     message=$(echo "${messageline}" | awk -F '|' '{printf $3}');;
        *)      message=$(echo "${messageline}" | awk -F '|' '{printf $5}');;
    esac

    # ログファイル出力用メッセージレベル
    priority=$(echo "${messageline}" | awk -F '|' '{printf $2}')
    # syslog出力用メッセージレベル
    syslog_priority=$(echo ${priority} | awk '{print tolower($0);}')
}

# ------------------------------------------------------------------------------
# ログ出力共通関数  
#           引数: [$1:出力ファイル名  $2:メッセージ文  $3:syslogファシリティー]
#           戻値: N/A
#           使用例: logWriter ${LOGFILE} "${message}"
#                   logWriter ${LOGFILE} "テストメッセージ"
#           考慮点: ${MSGMODE}変数の値を意識して下さい。 以下の指定を行っておく必要があります。
#                   [default=ファイル出力＆画面表示, syslog=syslog出力, mail=MAIL送信, silent=ログ出力のみ, display=画面表示のみ]
# ------------------------------------------------------------------------------
logWriter() {
(( ${DBG_FLG} )) && set -x

    # syslogファシリティー設定（優先度の低い変数から設定が上書きされます）
    syslog_facility=
    if [[ "${G_SYSLOG_FACILITY}" != "" ]]; then syslog_facility=${G_SYSLOG_FACILITY}; fi    # グローバルデフォルト
    if [[ "${SYSLOG_FACILITY}" != "" ]]; then syslog_facility=${SYSLOG_FACILITY}; fi        # スクリプトレベル
    if [[ "$3" != "" ]]; then syslog_facility=$3; fi                                        # メッセージ出力単位レベル
    
    # 出力モード分岐
    for mmode in $(echo ${MSGMODE:="default"} | sed 's/,/ /g')
    do
        case "${mmode}" in
            default)    echo "$(date +'%Y/%m/%d %T') ${HOSTNAME} ${messageid} ${priority} $2"|tee -a "$1";;
            syslog)     logger -p ${syslog_facility}.${syslog_priority:-info} -t ${priority} "$2";;
            display)    echo "$(date +'%Y/%m/%d %T') ${HOSTNAME} ${messageid} ${priority} $2";;
            silent)     echo "$(date +'%Y/%m/%d %T') ${HOSTNAME} ${messageid} ${priority} $2" >> "$1" 2>&1;;
            mail)       case $(echo "${priority}" | sed 's/ //g')  in
                            WARN|ERROR|CRIT)  sendMail "${SCR_NAME}: ${priority}Message from ${HOSTNAME}" "$2" "${MAIL_ADDR:=$G_MAIL_ADDR}" ;;
                            *)  : ;;
                        esac
                        ;;
            *)          : ;;
        esac
    done
}

# ------------------------------------------------------------------------------
# MAIL送信共通関数      
#           引数: [$1:タイトル  $2:本文  $3:アドレス]
#           戻値: N/A
#           使用例: sendMail "Mail Title" "This is test mail" "test@testdomain.local"
# ------------------------------------------------------------------------------
sendMail() {
(( ${DBG_FLG} )) && set -x
    echo "$2" | mail -s "$1" "$3"
}

# ------------------------------------------------------------------------------
# 監視重複メッセージ出力制御
#           引数: [$1:MSGレベル  $2:対象名]
#           戻値: N/A
# ------------------------------------------------------------------------------
checkDupMsg() {
(( ${DBG_FLG} )) && set -x
    _lock_file_name=${G_SCR_TMP_HOME}/${SCR_NAME}${G_SCR_LOCK_SFX:=.lck}

    case $1 in
        INFO)
            grep -s "$2:" ${_lock_file_name} > /dev/null 2>&1
            if [[ $? -eq 0 ]]; then
                grep -v "$2:" ${_lock_file_name} > ${_lock_file_name}.tmp
                mv ${_lock_file_name}.tmp ${_lock_file_name}
            fi
            ;;
        *)
            grep -s -i -w "^$1" ${_lock_file_name}|grep "$2:" > /dev/null 2>&1
            if [[ $? -eq 0 ]]; then
                MSGMODE=${EXCL_MSGMODE:=${G_EXCL_MSGMODE}}
            else
                echo "$1:$2:$(date +%Y%m%d%H%M%S)" >> ${_lock_file_name}
            fi
            ;;
    esac
}

# ------------------------------------------------------------------------------
# プロセスチェック共通関数      
#           引数: [$1:対象識別ID  $2:任意のプロセス文字列]
#           戻値: [$procid:PID一覧  $procs:プロセス数]
#           使用例: checkProcess "/usr/sbin/syslogd"
#                   checkProcess "DB2" "db2inst1"
#
#           考慮点: 引数が１つの場合は引数がプロセス名と判断されます。
# ------------------------------------------------------------------------------
checkProcess() {
(( ${DBG_FLG} )) && set -x

    procid=""
    procs=0
    
    case "$1" in
        DB2DAS) procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "db2dasrrm"| awk '{print $2}');;
        DB2)    procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "db2sysc"| awk '{print $2}');;
        HACMP)  procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "clstrmgr"| awk '{print $2}');;
        MQM)    procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|awk '{print $2}');;
        TSM)    procid=$(ps -eo comm,pid,user,args|grep -v grep|grep "dsmserv"| awk '{print $2}');;
        SQLCAP) procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "${G_SQLCAP_PROC:=asncap}"| awk '{print $2}');;
        SQLAPP) procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "${G_SQLAPP_PROC:=asnapp}"| awk '{print $2}');;
        QCAP)   procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "${G_QCAP_PROC:=asnqcap}"| awk '{print $2}');;
        QAPP)   procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "${G_QAPP_PROC:=asnqapp}"| awk '{print $2}');;
        #### 未確定  WAS)    procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$2"|grep -w "java"| awk '{print $2}');;
        *)      procid=$(ps -eo comm,pid,user,args|grep -v grep|grep -w "$1"|awk '{print $2}');;
    esac

    procs=$(echo ${procid}|wc -w|sed 's/ //g')
}

# ------------------------------------------------------------------------------
# トラップハンドリング
# ------------------------------------------------------------------------------
doTrapHandler() {
(( ${DBG_FLG} )) && set -x

    getMessage "999003W";logWriter ${LOGFILE} "${message}"
    RC=99
    finalizer
    exit $RC
}


# ------------------------------------------------------------------------------
# リターンコード判別メッセージ取得関数
#           引数: [$1:正常メッセージID  $2:異常メッセージID]
#           戻値: [$message:メッセージ本文]
# ------------------------------------------------------------------------------
checkRC() {
(( ${DBG_FLG} )) && set -x

    RC=$?
    case "$RC" in
        0)      getMessage "${1:-999001W}";;
        *)      getMessage "${2:-999001W}"
                message="${message} RC:${RC}";;
    esac
}

# ------------------------------------------------------------------------------
# エラーハンドリング関数
# ------------------------------------------------------------------------------
errorHandler() {
    :
}

# ------------------------------------------------------------------------------
# パスワード取得関数  
#           引数: [$1:ホスト名  $2:ユーザー名]
#           戻値: N/A
# ------------------------------------------------------------------------------
getPassword() {
(( ${DBG_FLG} )) && set -x

    _host=$1
    _uname=$2
    PASSWORD=

    # 対象(host)行が無い場合はCOMMON行を検索する
    _target_line=$(cat ${G_PWDFILE} | grep -w ^"$_host" |awk -F: '{ if($1 == "'$_host'" && $2 == "'$_uname'" ){print $0}}')
    if [[ "$_target_line" = "" ]]; then
        _host=COMMON
        PASSWORD=$(cat ${G_PWDFILE} | grep -w ^"$_host" |awk -F: '{ if($1 == "'$_host'" && $2 == "'$_uname'" ){print $3}}')
    else
        PASSWORD=$(cat ${G_PWDFILE} | grep -w ^"$_host" |awk -F: '{ if($1 == "'$_host'" && $2 == "'$_uname'" ){print $3}}')
    fi
}

# ------------------------------------------------------------------------------
# 実行ユーザチェック
# ------------------------------------------------------------------------------
checkExecUser() {
(( ${DBG_FLG} )) && set -x

    if [[ $(whoami) != "$1" ]]; then
        getMessage "OPE040W";logWriter ${LOGFILE} "${message} $(whoami) ではなく $1 で実行して下さい。"
        return 99
    fi
    
    USER_PROFILE=~/.profile
    return 0
}

# ------------------------------------------------------------------------------
# ユーザ情報取得
# ------------------------------------------------------------------------------
getUserInfo() {
(( ${DBG_FLG} )) && set -x
    userinfo=$(grep -w "$1" /etc/passwd | head -1)
    userhome=$(echo "$userinfo" | awk '{print $6}')
    return 0
}

# ------------------------------------------------------------------------------
# 実行サーバチェック
# ------------------------------------------------------------------------------
checkExecServer() {
(( ${DBG_FLG} )) && set -x

    if [[ ${HOSTNAME} != "$1" ]]; then
        getMessage "OPE041W";logWriter ${LOGFILE} "${message} $1 で実行して下さい。"
        return 99
    fi
    return 0
}

# ------------------------------------------------------------------------------
# ファイル存在確認
#           引数: [$1:対象ファイル名]
#           戻値: [エラーの場合99を戻す]
# ------------------------------------------------------------------------------
checkFileExist() {
(( ${DBG_FLG} )) && set -x

    _target_file=$1
    # ファイル存在チェック
    if [[ ! -s "${_target_file}" ]]; then 
        getMessage "OPE030C";logWriter ${LOGFILE} "TARGET FILE ${_target_file} ${message}"
        return 99
    fi
    return 0
}

# ------------------------------------------------------------------------------
# 監視ロックファイル存在確認
#           引数: [$1:対象ファイル名]
#           戻値: [0=存在無し  1=存在あり]
# ------------------------------------------------------------------------------
checkLckFile() {
(( ${DBG_FLG} )) && set -x

    _target_file=${G_SCR_TMP_HOME:=/tmp}/$1
    # ファイル存在チェック
    if [[ -f "${_target_file:=${G_WDLOCK}}" ]]; then 
        return 1
    fi
    return 0
}

# ------------------------------------------------------------------------------
# 監視ロックファイル削除
#           引数: [$1:識別子(任意)]
#           戻値: N/A
# ------------------------------------------------------------------------------
deleteLckFile() {
    cd "${G_SCR_TMP_HOME:=/tmp}/" && rm -f ./${1}*.${G_SCR_LOCK_SFX:=lck} > /dev/null 2>&1
}
